import{TAbstractDatabase as e,TAbstractDataController as t}from"itee-database";import{isDefined as r,isNull as n,isUndefined as a,isNotString as s}from"itee-validators";import l from"pg-promise";
/**
 * @author [Ahmed DCHAR]{@link https://github.com/dragoneel}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
class i extends e{static formatConnectionString(e){let t="";const{user:n,password:a,host:s,port:l,database:i}=e;return t=r(n)&&r(a)?`postgres://${n}:${a}@${s}:${l}/${i}`:`postgres://${s}:${l}/${i}`,t}constructor(e={}){const t={host:"localhost",port:"5432",database:"postgres",...e,driver:l({})(i.formatConnectionString(e))};super(t),this._user=t.user,this._password=t.password,this._host=t.host,this._port=t.port,this._database=t.database}init(){super.init()}connect(){this.driver.one(" SELECT 1 ",[]).then((()=>{this.logger.log(`PostgreSQL at postgres://${this._host}:${this._port}/${this._database} is connected !`)})).catch((e=>{this.logger.log("PostgreSQL - Connection error ",e)}))}on(){}close(e){this.driver.end(),e()}}class o extends t{constructor(e={}){const t={driver:null,tableName:"",tableFields:[],...e};super(t),this.tableName=t.tableName,this.tableFields=t.tableFields}get tableFields(){return this._tableFields}set tableFields(e){const t="Expect an instance of Array of String.";if(n(e))throw new TypeError(`Table fields cannot be null ! ${t}`);if(a(e))throw new TypeError(`Table fields cannot be undefined ! ${t}`);let r="";for(let t=0,n=e.length;t<n;t++)r+=`${e[t]}, `;this._tableFields=r.slice(0,-2)}get tableName(){return this._tableName}set tableName(e){const t="Expect an instance of String.";if(n(e))throw new TypeError(`Table name cannot be null ! ${t}`);if(a(e))throw new TypeError(`Table name cannot be undefined ! ${t}`);if(s(e))throw new TypeError(`Table name cannot be an instance of ${e.constructor.name} ! ${t}`);this._tableName=e}setTableName(e){return this.tableName=e,this}_createMany(e,r){super._createOne(e,r);const n=[],a=[];let s=e.length,l=null,i=null,o=null,h=null,u=null,d=null,c=null;for(let _ in e){l=e[_],i=Object.keys(l),o=Object.values(l),h=0,u="(",d="(";for(let e in i)h++,u+=`${e}, `,d+=`$${h}, `;u=u.slice(0,-2),d=d.slice(0,-2),u+=")",d+=")",c=`INSERT INTO ${this._tableName} ${u} VALUES ${d}`,this._driver.one(c,o).then((e=>{n.push(e)})).catch((e=>{a.push(e)})).finally((()=>{if(s--,s>0)return;const e=n.length>0,l=a.length>0;e&&l?t.returnErrorAndData(a,n,r):!e&&l?t.returnError(a,r):e&&!l?t.returnData(n,r):e||l||t.returnData(null,r)}))}}_createOne(e,r){super._createOne(e,r);const n=Object.keys(e),a=Object.values(e);let s=0,l="(",i="(";for(let e in n)s++,l+=`${e}, `,i+=`$${s}, `;l=l.slice(0,-2),i=i.slice(0,-2),l+=")",i+=")";let o=`INSERT INTO ${this._tableName} ${l} VALUES ${i}`;this._driver.one(o,a).then((e=>{t.returnData(e,r)})).catch((e=>{t.returnError(e,r)}))}_deleteAll(e){super._deleteAll(e),this._driver.one(` TRUNCATE TABLE ${this._tableName} `).then((r=>{t.returnData(r,e)})).catch((r=>{t.returnError(r,e)}))}_deleteMany(e,r){super._deleteMany(e,r),this._driver.any(` DELETE FROM ${this._tableName} WHERE id IN ($1:list) `,[e]).then((e=>{t.returnData(e,r)})).catch((e=>{t.returnError(e,r)}))}_deleteOne(e,r){super._deleteOne(e,r),this._driver.one(` DELETE FROM ${this._tableName} WHERE id=$1 `,[e]).then((e=>{t.returnData(e,r)})).catch((e=>{t.returnError(e,r)}))}_deleteWhere(e,r){super._deleteWhere(e,r),t.returnError("DeleteWhere method is not implemented yet ! Sorry for the disagrement.",r)}_readAll(e,r){super._readAll(e,r),this._driver.any(` SELECT ${this._tableFields} FROM ${this._tableName} `).then((e=>{t.returnData(e,r)})).catch((e=>{t.returnError(e,r)}))}_readMany(e,r,n){super._readMany(e,r,n),this._driver.any(` SELECT ${this._tableFields} FROM ${this._tableName} WHERE id IN ($1:list)`,[e]).then((e=>{t.returnData(e,n)})).catch((e=>{t.returnError(e,n)}))}_readOne(e,r,n){super._readOne(e,r,n),this._driver.one(` SELECT ${this._tableFields} FROM ${this._tableName} WHERE id = $1 `,[e]).then((e=>{t.returnData(e,n)})).catch((e=>{t.returnError(e,n)}))}_readWhere(e,r,n){super._readWhere(e,r,n),this._driver.any(` SELECT ${this._tableFields} FROM ${this._tableName} WHERE ${r}`).then((e=>{t.returnData(e,n)})).catch((e=>{t.returnError(e,n)}))}_updateAll(e,r){super._updateAll(e,r),t.returnError("UpdateAll method is not implemented yet ! Sorry for the disagrement.",r)}_updateMany(e,r,n){super._updateMany(e,r,n);const a=e.length,s=r.length;if(a!==s)return void t.returnError("Number of ids doesn't match the number of updates. Abort updates !",n);const l=[],i=[];let o=a,h=null,u=null,d=null,c=null,_=null,E=null,p=null,b=null;for(let a=0;a<s;a++){h=e[a],u=r[a],d=Object.keys(u),c=Object.values(u),_=1,E="";for(let e in d)_++,E+=`${e}=$${_}, `;E=E.slice(0,-2),E+=")",p=` UPDATE ${this._tableName} SET ${E} WHERE id=$1 `,b=[h].concat(c),this._driver.one(p,b).then((e=>{l.push(e)})).catch((e=>{i.push(e)})).finally((()=>{if(o--,o>0)return;const e=l.length>0,r=i.length>0;e&&r?t.returnErrorAndData(i,l,n):!e&&r?t.returnError(i,n):e&&!r?t.returnData(l,n):e||r||t.returnData(null,n)}))}}_updateOne(e,r,n){super._updateOne(e,r,n);const a=Object.keys(r),s=Object.values(r);let l=1,i="";for(let e in a)l++,i+=`${e}=$${l}, `;i=i.slice(0,-2),i+=")";let o=` UPDATE ${this._tableName} SET ${i} WHERE id=$1 `,h=[e].concat(s);this._driver.one(o,h).then((e=>{t.returnData(e,n)})).catch((e=>{t.returnError(e,n)}))}_updateWhere(e,r,n){super._updateWhere(e,r,n),t.returnError("UpdateWhere method is not implemented yet ! Sorry for the disagrement.",n)}}export{o as TPostgreSQLController,i as TPostgreSQLDatabase};
