import e from"pg-promise";import{isDefined as r,isArray as t,isObject as n,isString as a,isFunction as s,isNotDefined as o,isEmptyArray as i,isEmptyObject as u,isNotString as l,isEmptyString as d,isBlankString as c,isNotArray as p,isNotObject as h,isNull as f,isUndefined as m}from"itee-validators";import _ from"path";import{kStringMaxLength as E}from"buffer";import b from"fs";import{Writable as g}from"stream";console.log("Itee.Database v8.0.0 - EsModule");
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TDatabaseController
 * @classdesc The TDatabaseController is the base class to perform CRUD operations on the database
 */
class y{static __checkData(e,t,n){const a=t.body,s=t.params,o=t.query;return r(a)&&a[e]?a[e]:r(s)&&s[e]?s[e]:r(o)&&o[e]?o[e]:void y.returnError({title:"Erreur de paramètre",message:`${e} n'existe pas dans les paramètres !`},n)}static _formatError(e){let r=[];if(t(e))for(let t=0,n=e.length;t<n;++t)r=r.concat(y._formatError(e[t]));else if(n(e))if("ValidationError"===e.name){let t="",n=e.errors;for(let e in n)Object.prototype.hasOwnProperty.call(n,e)&&(t+=n[e].message+"<br>");r.push({title:"Erreur de validation",message:t||"Aucun message d'erreur... Gloups !"})}else"VersionError"===e.name?r.push({title:"Erreur de base de donnée",message:"Aucun document correspondant n'as put être trouvé pour la requete !"}):r.push({title:e.title||"Erreur",message:e.message||"Aucun message d'erreur... Gloups !"});else{if(!a(e))throw new Error(`Unknown error type: ${e} !`);r.push({title:"Erreur",message:e})}return r}static returnNotFound(e){if(s(e))return e();e.headersSent||e.status(204).end()}static returnError(e,r){if(s(r))return r(e,null);if(r.headersSent)return;const t=y._formatError(e);r.format({"application/json":()=>{r.status(500).json(t)},default:()=>{r.status(406).send("Not Acceptable")}})}static returnData(e,r){if(s(r))return r(null,e);if(r.headersSent)return;const n=t(e)?e:[e];r.format({"application/json":()=>{r.status(200).json(n)},default:()=>{r.status(406).send("Not Acceptable")}})}static returnErrorAndData(e,r,t){if(s(t))return t(e,r);if(t.headersSent)return;const n={errors:e,datas:r};t.format({"application/json":()=>{t.status(416).json(n)},default:()=>{t.status(416).send("Range Not Satisfiable")}})}constructor(e={}){const r={driver:null,useNext:!1,...e};this._driver=r.driver,this._useNext=r.useNext}return(e,t={}){const n=Object.assign({immediate:null,beforeAll:null,beforeReturnErrorAndData:null,afterReturnErrorAndData:null,beforeReturnError:null,afterReturnError:null,beforeReturnData:null,afterReturnData:null,beforeReturnNotFound:null,afterReturnNotFound:null,afterAll:null},t,{returnErrorAndData:y.returnErrorAndData.bind(this),returnError:y.returnError.bind(this),returnData:y.returnData.bind(this),returnNotFound:y.returnNotFound.bind(this)});return n.immediate&&n.immediate(),function(t=null,a=null){const s=r(a),o=r(t);n.beforeAll&&n.beforeAll(),s&&o?(n.beforeReturnErrorAndData&&n.beforeReturnErrorAndData(t,a),n.returnErrorAndData(t,a,e),n.afterReturnErrorAndData&&n.afterReturnErrorAndData(t,a)):s&&!o?(n.beforeReturnData&&n.beforeReturnData(a),n.returnData(a,e),n.afterReturnData&&n.afterReturnData(a)):!s&&o?(n.beforeReturnError&&n.beforeReturnError(t),n.returnError(t,e),n.afterReturnError&&n.afterReturnError(t)):s||o||(n.beforeReturnNotFound&&n.beforeReturnNotFound(),n.returnNotFound(e),n.afterReturnNotFound&&n.afterReturnNotFound()),n.afterAll&&n.afterAll()}}create(e,r,a){const s=e.body;o(s)?y.returnError({title:"Erreur de paramètre",message:"Le corps de la requete ne peut pas être null ou indefini."},this._useNext?a:r):t(s)?i(s)?y.returnError({title:"Erreur de paramètre",message:"Le tableau d'objet de la requete ne peut pas être vide."},this._useNext?a:r):this._createMany(s,r,a):n(s)?u(s)?y.returnError({title:"Erreur de paramètre",message:"L'objet de la requete ne peut pas être vide."},this._useNext?a:r):this._createOne(s,r,a):y.returnError({title:"Erreur de paramètre",message:"Le type de donnée de la requete est invalide. Les paramètres valides sont objet ou un tableau d'objet."},this._useNext?a:r)}_createOne(){}_createMany(){}read(e,t,n){const a=e.params.id,s=e.body,o=r(s),f=o?s.ids:null,m=o?s.query:null,_=o?s.projection:null;r(a)?l(a)?y.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?n:t):d(a)||c(a)?y.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?n:t):this._readOne(a,_,t,n):r(f)?p(f)?y.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?n:t):i(f)?y.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?n:t):this._readMany(f,_,t,n):r(m)?h(m)?y.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?n:t):u(m)?this._readAll(_,t,n):this._readWhere(m,_,t,n):y.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être null."},this._useNext?n:t)}_readOne(){}_readMany(){}_readWhere(){}_readAll(){}update(e,t,n){const a=e.params.id,s=e.body,f=r(s),m=f?s.ids:null,_=f?s.query:null,E=f?s.update:null;o(E)?y.returnError({title:"Erreur de paramètre",message:"La mise à jour a appliquer ne peut pas être null ou indefini."},this._useNext?n:t):r(a)?l(a)?y.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?n:t):d(a)||c(a)?y.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?n:t):this._updateOne(a,E,t,n):r(m)?p(m)?y.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?n:t):i(m)?y.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?n:t):this._updateMany(m,E,t,n):r(_)?h(_)?y.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?n:t):u(_)?this._updateAll(E,t,n):this._updateWhere(_,E,t,n):y.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être vide."},this._useNext?n:t)}_updateOne(){}_updateMany(){}_updateWhere(){}_updateAll(){}delete(e,t,n){const a=e.params.id,s=e.body,o=r(s),f=o?s.ids:null,m=o?s.query:null;r(a)?l(a)?y.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?n:t):d(a)||c(a)?y.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?n:t):this._deleteOne(a,t,n):r(f)?p(f)?y.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?n:t):i(f)?y.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?n:t):this._deleteMany(f,t,n):r(m)?h(m)?y.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?n:t):u(m)?this._deleteAll(t,n):this._deleteWhere(m,t,n):y.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être vide."},this._useNext?n:t)}_deleteOne(){}_deleteMany(){}_deleteWhere(){}_deleteAll(){}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class v extends g{constructor(e){super(e);const r=e.bufferSize||E;this.memoryBuffer=Buffer.alloc(r),this.offset=0}_final(e){e()}_write(e,r,t){const n=Buffer.isBuffer(e)?e:new Buffer(e,r);for(let e=0,r=n.length;e<r;e++)this.memoryBuffer[this.offset]=n[e],this.offset++;t()}_writev(e,r){for(let r=0,t=e.length;r<t;r++)this.memoryBuffer=Buffer.concat([this.memoryBuffer,e[r]]);r()}_releaseMemory(){this.memoryBuffer=null}toArrayBuffer(){const e=this.memoryBuffer,r=new ArrayBuffer(e.length),t=new Uint8Array(r);for(let r=0;r<e.length;++r)t[r]=e[r];return this._releaseMemory(),r}toJSON(){return JSON.parse(this.toString())}toString(){const e=this.memoryBuffer.toString();return this._releaseMemory(),e}}class N{constructor(e={}){const r={dumpType:N.DumpType.ArrayBuffer,...e};this.dumpType=r.dumpType,this._isProcessing=!1,this._queue=[]}get dumpType(){return this._dumpType}set dumpType(e){if(f(e))throw new TypeError("Dump type cannot be null ! Expect a non empty string.");if(m(e))throw new TypeError("Dump type cannot be undefined ! Expect a non empty string.");this._dumpType=e}setDumpType(e){return this.dumpType=e,this}convert(e,r,t,n,a){e?(this._queue.push({file:e,parameters:r,onSuccess:t,onProgress:n,onError:a}),this._processQueue()):a("File cannot be null or empty, aborting file convertion !!!")}_processQueue(){if(0===this._queue.length||this._isProcessing)return;this._isProcessing=!0;const e=this,r=this._queue.shift(),t=r.file,n=r.parameters,s=r.onSuccess,o=r.onProgress,i=r.onError;if(a(t))e._dumpFileInMemoryAs(e._dumpType,t,n,u,d,c);else{const r=t.data;switch(e._dumpType){case N.DumpType.ArrayBuffer:{const e=r.length,t=new ArrayBuffer(e),n=new Uint8Array(t);for(let t=0;t<e;++t)n[t]=r[t];u(t)}break;case N.DumpType.JSON:u(JSON.parse(r.toString()));break;case N.DumpType.String:u(r.toString());break;default:throw new RangeError(`Invalid switch parameter: ${e._dumpType}`)}}function u(r){e._convert(r,n,l,d,c)}function l(r){s(r),e._isProcessing=!1,e._processQueue()}function d(e){o(e)}function c(r){i(r),e._isProcessing=!1,e._processQueue()}}_dumpFileInMemoryAs(e,r,t,n,a,s){let o=!1;const i=b.createReadStream(r);i.on("error",e=>{console.error(`Read stream on error: ${e}`),o=!0,s(e)});const u=parseInt(t.fileSize),l=new v({bufferSize:u});l.on("error",e=>{o=!0,s(e)}),l.on("finish",()=>{if(!o){switch(e){case N.DumpType.ArrayBuffer:n(l.toArrayBuffer());break;case N.DumpType.String:n(l.toString());break;case N.DumpType.JSON:n(l.toJSON());break;default:throw new RangeError(`Invalid switch parameter: ${e}`)}i.unpipe(),i.close(),l.end()}}),i.pipe(l)}_convert(){}}N.MAX_FILE_SIZE=67108864,N.DumpType=Object.freeze({ArrayBuffer:0,String:1,JSON:2});
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
class T{static _registerRoutesTo(e,r,t,n,a){for(let s=0,o=a.length;s<o;s++){const o=a[s],i=new(n.get(o.controller.name))({driver:e,...o.controller.options}),u=t({mergeParams:!0});console.log(`\tAdd controller for base route: ${o.route}`),r.use(o.route,T._populateRouter(u,i,o.controller.can))}}static _populateRouter(e,r,t={}){for(let n in t){const a=t[n];console.log(`\t\tMap route ${a.over} on (${a.on}) to ${r.constructor.name}.${n} method.`),e[a.on](a.over,r[n].bind(r))}return e}constructor(e={}){const r={controllers:new Map,descriptors:[],...e};this.controllers=r.controllers,this.descriptors=r.descriptors,this.__dirname=void 0}get controllers(){return this._controllers}set controllers(e){if(f(e))throw new TypeError("Controllers cannot be null ! Expect a map of controller.");if(m(e))throw new TypeError("Controllers cannot be undefined ! Expect a map of controller.");if(!(e instanceof Map))throw new TypeError(`Controllers cannot be an instance of ${e.constructor.name} ! Expect a map of controller.`);this._controllers=e}get descriptors(){return this._descriptors}set descriptors(e){if(f(e))throw new TypeError("Descriptors cannot be null ! Expect an array of POJO.");if(m(e))throw new TypeError("Descriptors cannot be undefined ! Expect an array of POJO.");this._descriptors=e}addController(e){return this._controllers.set(e.name,e),this}addDescriptor(e){return this._descriptors.push(e),this}beforeRegisterRoutes(){}registerTo(e,r,t){this.beforeRegisterRoutes(e),T._registerRoutesTo(e,r,t,this._controllers,this._descriptors)}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
/**
 * @author [Ahmed DCHAR]{@link https://github.com/dragoneel}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
const $=e({});class A extends class{constructor(e={}){const r={driver:null,application:null,router:null,plugins:[],...e};this.driver=r.driver,this.application=r.application,this.router=r.router,this.plugins=r.plugins,this.init(),this._registerPlugins()}get plugins(){return this._plugins}set plugins(e){if(f(e))throw new TypeError("Plugins cannot be null ! Expect an array of TDatabasePlugin.");if(m(e))throw new TypeError("Plugins cannot be undefined ! Expect an array of TDatabasePlugin.");this._plugins=e}get router(){return this._router}set router(e){if(f(e))throw new TypeError("Router cannot be null ! Expect a Express Router.");if(m(e))throw new TypeError("Router cannot be undefined ! Expect a Express Router.");this._router=e}get application(){return this._application}set application(e){if(f(e))throw new TypeError("Application cannot be null ! Expect a Express Application.");if(m(e))throw new TypeError("Application cannot be undefined ! Expect a Express Application.");this._application=e}get driver(){return this._driver}set driver(e){if(f(e))throw new TypeError("Driver cannot be null ! Expect a database driver.");if(m(e))throw new TypeError("Driver cannot be undefined ! Expect a database driver.");this._driver=e}setPlugins(e){return this.plugins=e,this}setRouter(e){return this.router=e,this}setApplication(e){return this.application=e,this}setDriver(e){return this.driver=e,this}init(){}_registerPlugins(){for(let[e,r]of Object.entries(this._plugins))this._registerPackagePlugin(e,r)?console.log(`Use ${e} plugin from node_modules`):this._registerLocalPlugin(e,r)?console.log(`Use ${e} plugin from local folder`):console.error(`Unable to register the plugin ${e} the package or local folder doesn't seem to exist ! Skip it.`)}_registerPackagePlugin(e){let r=!1;try{const t=require(e);t instanceof T?(t.__dirname=_.dirname(require.resolve(e)),t.registerTo(this._driver,this._application,this._router),r=!0):console.error(`The plugin ${e} doesn't seem to be an instance of an extended class from TAbstractDatabasePlugin ! Skip it.`)}catch(e){e.code&&"MODULE_NOT_FOUND"===e.code||console.error(e)}return r}_registerLocalPlugin(e){let r=!1;try{const t=_.join(__dirname,"../../../","databases/plugins/",e,`${e}.js`),n=require(t);n instanceof T?(n.__dirname=_.dirname(require.resolve(t)),n.registerTo(this._driver,this._application,this._router),r=!0):console.error(`The plugin ${e} doesn't seem to be an instance of an extended class from TAbstractDatabasePlugin ! Skip it.`)}catch(e){console.error(e)}return r}connect(){}close(){}on(){}}{constructor(e={}){const r={host:"localhost",port:"5432",database:"postgres",...e,driver:$};super(r),this._host=r.host,this._port=r.port,this._database=r.database}close(){}connect(){this._driver.one(" SELECT 1 ",[]).then(e=>{console.log(`PostgreSQL at ${this._host}:${this._port}/${this._database} is connected ! ${e}`)}).catch(e=>{console.log("PostgreSQL - Connection error ",e)})}init(){super.init()}on(){}}class D extends y{constructor(e={}){const r={driver:null,tableName:"",tableFields:[],...e};super(r),this.tableName=r.tableName,this.tableFields=r.tableFields}get tableFields(){return this._tableFields}set tableFields(e){const r="Expect an instance of Array of String.";if(f(e))throw new TypeError(`Table fields cannot be null ! ${r}`);if(m(e))throw new TypeError(`Table fields cannot be undefined ! ${r}`);let t="";for(let r=0,n=e.length;r<n;r++)t+=`${e[r]}, `;this._tableFields=t.slice(0,-2)}get tableName(){return this._tableName}set tableName(e){const r="Expect an instance of String.";if(f(e))throw new TypeError(`Table name cannot be null ! ${r}`);if(m(e))throw new TypeError(`Table name cannot be undefined ! ${r}`);if(l(e))throw new TypeError(`Table name cannot be an instance of ${e.constructor.name} ! ${r}`);this._tableName=e}setTableName(e){return this.tableName=e,this}_createMany(e,r){super._createOne(e,r);const t=[],n=[];let a=e.length,s=null,o=null,i=null,u=null,l=null,d=null,c=null;for(let p in e){s=e[p],o=Object.keys(s),i=Object.values(s),u=0,l="(",d="(";for(let e in o)u++,l+=`${e}, `,d+=`$${u}, `;l=l.slice(0,-2),d=d.slice(0,-2),l+=")",d+=")",c=`INSERT INTO ${this._tableName} ${l} VALUES ${d}`,this._driver.one(c,i).then(e=>{t.push(e)}).catch(e=>{n.push(e)}).finally(()=>{if(a--,a>0)return;const e=t.length>0,s=n.length>0;e&&s?y.returnErrorAndData(n,t,r):!e&&s?y.returnError(n,r):e&&!s?y.returnData(t,r):e||s||y.returnData(null,r)})}}_createOne(e,r){super._createOne(e,r);const t=Object.keys(e),n=Object.values(e);let a=0,s="(",o="(";for(let e in t)a++,s+=`${e}, `,o+=`$${a}, `;s=s.slice(0,-2),o=o.slice(0,-2),s+=")",o+=")";let i=`INSERT INTO ${this._tableName} ${s} VALUES ${o}`;this._driver.one(i,n).then(e=>{y.returnData(e,r)}).catch(e=>{y.returnError(e,r)})}_deleteAll(e){super._deleteAll(e),this._driver.one(` TRUNCATE TABLE ${this._tableName} `).then(r=>{y.returnData(r,e)}).catch(r=>{y.returnError(r,e)})}_deleteMany(e,r){super._deleteMany(e,r),this._driver.any(` DELETE FROM ${this._tableName} WHERE id IN ($1:list) `,[e]).then(e=>{y.returnData(e,r)}).catch(e=>{y.returnError(e,r)})}_deleteOne(e,r){super._deleteOne(e,r),this._driver.one(` DELETE FROM ${this._tableName} WHERE id=$1 `,[e]).then(e=>{y.returnData(e,r)}).catch(e=>{y.returnError(e,r)})}_deleteWhere(e,r){super._deleteWhere(e,r),y.returnError("DeleteWhere method is not implemented yet ! Sorry for the disagrement.",r)}_readAll(e,r){super._readAll(e,r),this._driver.any(` SELECT ${this._tableFields} FROM ${this._tableName} `).then(e=>{y.returnData(e,r)}).catch(e=>{y.returnError(e,r)})}_readMany(e,r,t){super._readMany(e,r,t),this._driver.any(` SELECT ${this._tableFields} FROM ${this._tableName} WHERE id IN ($1:list)`,[e]).then(e=>{y.returnData(e,t)}).catch(e=>{y.returnError(e,t)})}_readOne(e,r,t){super._readOne(e,r,t),this._driver.one(` SELECT ${this._tableFields} FROM ${this._tableName} WHERE id = $1 `,[e]).then(e=>{y.returnData(e,t)}).catch(e=>{y.returnError(e,t)})}_readWhere(e,r,t){super._readWhere(e,r,t),this._driver.any(` SELECT ${this._tableFields} FROM ${this._tableName} WHERE ${r}`).then(e=>{y.returnData(e,t)}).catch(e=>{y.returnError(e,t)})}_updateAll(e,r){super._updateAll(e,r),y.returnError("UpdateAll method is not implemented yet ! Sorry for the disagrement.",r)}_updateMany(e,r,t){super._updateMany(e,r,t);const n=e.length,a=r.length;if(n!==a)return void y.returnError("Number of ids doesn't match the number of updates. Abort updates !",t);const s=[],o=[];let i=n,u=null,l=null,d=null,c=null,p=null,h=null,f=null,m=null;for(let n=0;n<a;n++){u=e[n],l=r[n],d=Object.keys(l),c=Object.values(l),p=1,h="";for(let e in d)p++,h+=`${e}=$${p}, `;h=h.slice(0,-2),h+=")",f=` UPDATE ${this._tableName} SET ${h} WHERE id=$1 `,m=[u].concat(c),this._driver.one(f,m).then(e=>{s.push(e)}).catch(e=>{o.push(e)}).finally(()=>{if(i--,i>0)return;const e=s.length>0,r=o.length>0;e&&r?y.returnErrorAndData(o,s,t):!e&&r?y.returnError(o,t):e&&!r?y.returnData(s,t):e||r||y.returnData(null,t)})}}_updateOne(e,r,t){super._updateOne(e,r,t);const n=Object.keys(r),a=Object.values(r);let s=1,o="";for(let e in n)s++,o+=`${e}=$${s}, `;o=o.slice(0,-2),o+=")";let i=` UPDATE ${this._tableName} SET ${o} WHERE id=$1 `,u=[e].concat(a);this._driver.one(i,u).then(e=>{y.returnData(e,t)}).catch(e=>{y.returnError(e,t)})}_updateWhere(e,r,t){super._updateWhere(e,r,t),y.returnError("UpdateWhere method is not implemented yet ! Sorry for the disagrement.",t)}}export{D as TPostgreSQLController,A as TPostgreSQLDatabase};
